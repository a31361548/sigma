# 新功能提案：智慧扇出排版（Smart Partial Layout）

## 目標描述
強化 `SigmaCanvas.tsx` 中的部分重排（Partial Re-layout）邏輯，解決在節點展開時子節點與父節點重疊的問題。首選策略專注於高性能 O(N) 幾何計算，確保在 5000+ 節點下操作依然流暢。

---

## 用戶審查事項（User Review Required）
- 確認策略：首選「動態間距 + 區間掃描」，備用「輕量力引導」。
- 副作用預告：若該層級節點極多，為避免重疊，子節點可能會被推到較遠的上下方（必要犧牲）。

---

## 策略詳情（Strategy Details）

### 核心原則：輕量切換，智慧展開
排版邏輯拆分為兩個層次，以達到效能與效果的最佳平衡。

### 1) 輕量切換（Lightweight Mode Switching）
- 觸發時機：切換 Structure / Circle 模式（透過 `relayoutVisibleStructuralNodes`）。
- 邏輯：維持現有簡單幾何計算（依父節點位置重算座標）。
- 理由：切換模式涉及全圖或大量節點，若此時做碰撞檢測會導致全圖劇烈跳動且效能成本過高；此處不做碰撞避讓。

### 2) 智慧展開（Smart Expansion with 2D Avoidance）
- 觸發時機：僅在 `handleExpandNode`（使用者右鍵展開單一節點）時觸發。
- 邏輯：動態幾何佔位 + 2D 雙向避讓。

#### A. 動態 X 推移（Dynamic minDx）
- 計算公式：`minDx = 300 (Base) + (ParentSize * 12) + (LabelLength * 14)`。
- 目的：確保初始 X 落點就不會壓到父節點的 Icon 或文字。

#### B. 2D 雙向避讓（Bidirectional 2D Avoidance）
- 掃描範圍：以目標位置為中心，寬高約 `60 + childSize * 2` 的局部視窗。
- 障礙物判定：掃描所有「可見節點」（包含 Pinned 節點，視為固定障礙物）。
- 避讓演算法：
  1) 檢查原點：若預設位置無碰撞，直接放置。
  2) Y 軸雙向搜尋：若碰撞，同時嘗試 +Step（下）與 -Step（上）。
     - Step：`max(40, childSize * 2)`
     - Y 搜尋範圍：`±200px`
  3) X 軸推移：若上下搜尋超過範圍仍無空位，將整排子節點往右（X+）推移，再重新找 Y 空位。
     - X 推移增量：`+160px`
- 碰撞框：`childSize * 2 + 10`
- 優勢：選擇移動距離最小的空位，避免盲目往下推造成結構過度細長。

---

## 備用策略（Fallback）
**輕量力引導（Leg-constrained Force）**：僅在上述幾何避讓演算法運算超過閾值（例如找不到空位超過 50 次）時觸發，作為最後手段。

---

## 擬定變更（Proposed Changes）
`[sigma/src/components/Graph]`

[MODIFY] `SigmaCanvas.tsx`
- 分離邏輯：
  - 保持 `relayoutVisibleStructuralNodes` 簡單快速。
  - 強化 `handleExpandNode`，在其中實作 `FindSmartPosition` 邏輯。
- 實作 `calculateDynamicMinDx`：
  - 加入 Label 寬度估算。
- 實作 `findSmartPosition2DHelper`：
  - 輸入：預設 `(x, y)`、子節點大小。
  - 輸出：避讓後的安全 `(bestX, bestY)`。
  - 內含 `isOccupied(rect)` 檢測與雙向搜尋迴圈。

---

## 驗證計畫（Verification Plan）

### 自動化測試
- `npm run build`：確保無 TypeScript 錯誤。

### 手動驗證
- 啟動：`npm run dev`。
- 情境測試：
  1) 找一個名字很長（例如 10 個字）的理專節點，按右鍵「展開」。
     - 預期結果：子節點出現在更右邊，沒有壓到文字。
  2) 找一個上下都有其他節點的擁擠區域，按右鍵「展開」。
     - 預期結果：子節點自動「見縫插針」，上下平移避開了鄰居。
