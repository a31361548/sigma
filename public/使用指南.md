# Sigma.js v3 使用方法總整理（Core + Satellite Packages）

> 本文以 sigma.js 官方文件（Quickstart / Advanced topics / Renderers / Sizes / New packages 等）為主，整理成一份「可直接拿去實作」的手冊。
>
> ⚠️ 注意：由於 npmjs.com 目前對部分爬取請求回傳 403，少數 **Satellite package 的 API 函式名稱**（例如 `bindXXXLayer` / `createNodeXXXProgram`）我只能依據官方 Renderers 文件與 Storybook source 片段推斷，可能存在 **命名差異**。實作時建議以 IDE 自動完成或 `import { ... } from "@sigma/..."` 的實際 exports 為準。

---

<a id="quick-guide"></a>
## 快速導讀

* **想先跑起來**：看第 2、4 章（安裝、初始化 renderer）
* **想做互動（點選/hover/拖曳/置中）**：看第 6、7 章（Camera、Events）
* **想改外觀（顏色/尺寸/label/自訂 program）**：看第 5、8、9 章（Settings、Reducers、Programs）
* **想處理大圖效能（節點多/label 多）**：看第 12 章（效能最佳實務）
* **想做固定排版/多中心群**：直接跳第 15 章（ELK 排版策略）

## 目錄

* [快速導讀](#quick-guide)
* [1. 核心概念](#1-核心概念)
* [2. 安裝與最小可運行範例](#2-安裝與最小可運行範例)
* [3. Graphology 資料模型與資料結構建議](#3-graphology-資料模型與資料結構建議)
* [4. 初始化 Sigma Renderer](#4-初始化-sigma-renderer)
* [5. 常用設定（Settings）](#5-常用設定settings)
* [6. Camera（平移/縮放/置中/框選）](#6-camera平移縮放置中框選)
* [7. Events（互動事件與 picking）](#7-events互動事件與-picking)
* [8. 渲染資料流程：Reducers / DisplayData / 自訂外觀](#8-渲染資料流程reducers--displaydata--自訂外觀)
* [9. Renderers 與 Programs（核心 WebGL 程式）](#9-renderers-與-programscore-webgl-程式)
* [10. 尺寸與座標系統（Sizes & Coordinates）](#10-尺寸與座標系統sizes--coordinates)
* [11. Layers（額外圖層）](#11-layers額外圖層)
* [12. 效能與大圖最佳實務](#12-效能與大圖最佳實務)
* [13. Satellite Packages 全整理（@sigma/*）](#13-satellite-packages-全整理sigma)
* [14. 常見整合情境範本](#14-常見整合情境範本)
  * [14.5 你接下來如果要我更「完全對齊 Storybook」](#toc-145)
  * [14.6 補充：@react-sigma / Settings 參數 / 事件 Payload / 動畫](#toc-146)
* [15. 多中心群（理專 → 客戶 → 帳戶）：ELK 排版策略](#15-多中心群理專--客戶--帳戶elk-排版策略純策略---可直接落地)
  * [15.1 目標](#151-目標)
  * [15.2 推薦 Pipeline](#152-推薦-pipeline最穩最好調參)
  * [15.3 群內 layout：ELK layered](#153-群內-layout為什麼預設選-elk-layered)
  * [15.4 群間 packing：多中心不重疊](#154-群間-packing多中心不重疊的關鍵)
  * [15.8 心智圖／拓樸圖／網狀圖對照](#158-心智圖拓樸圖網狀圖常用布局演算法對照你要的範例補齊)

---

## 1. 核心概念

Sigma.js 的定位很明確：

* **graphology**：負責「圖資料模型、增刪改查、演算法、layout 計算（多數）」
* **sigma**：負責「WebGL 高效渲染 + 互動（hover / click / drag / camera）」

Sigma 本身幾乎不提供 graph algorithm；若你要 ForceAtlas2 / Noverlap / Louvain 等，通常走 graphology 生態。

---

## 2. 安裝與最小可運行範例

### 2.1 安裝

```bash
npm install sigma graphology
```

### 2.2 最小例子（TypeScript）

```ts
import Graph from "graphology";
import Sigma from "sigma";

type NodeAttrs = {
  x: number;
  y: number;
  size: number;
  label?: string;
  color?: string;
  type?: string;
};

type EdgeAttrs = {
  size?: number;
  color?: string;
  type?: string;
};

const graph = new Graph<NodeAttrs, EdgeAttrs>();

graph.addNode("1", { label: "Node 1", x: 0, y: 0, size: 10, color: "#3b82f6" });
graph.addNode("2", { label: "Node 2", x: 1, y: 1, size: 20, color: "#ef4444" });

graph.addEdge("1", "2", { size: 2, color: "#a855f7" });

const container = document.getElementById("container");
if (!container) throw new Error("Missing #container");

const renderer = new Sigma(graph, container);

// 用完記得 renderer.kill();
```

> 你需要確保 container 有尺寸（例如 CSS 給寬高），否則看起來會像沒渲染。

---

## 3. Graphology 資料模型與資料結構建議

### 3.1 最重要的「可畫」屬性

Sigma 要畫出來通常至少需要：

* Node：`x`, `y`, `size`（以及常見的 `label`, `color`）
* Edge：通常只要 source/target 存在即可，`size`/`color` 可選

### 3.2 建議的 Node/Edge attrs 形狀

如果你要支援多種渲染/互動/自訂：

```ts
type NodeAttrs = {
  x: number;
  y: number;
  size: number;
  label?: string;
  color?: string;
  type?: string;

  // Satellite packages 可能用到：
  image?: string; // node-image
  borderColor?: string; // node-border
  borderSize?: number; // node-border
  pie?: ReadonlyArray<{ color: string; value: number }>; // node-piechart（概念）
};

type EdgeAttrs = {
  size?: number;
  color?: string;
  type?: string;
  curvature?: number; // edge-curve（概念）
};
```

> 具體欄位名稱要跟你設定的 reducers / programs 對齊。

---

## 4. 初始化 Sigma Renderer

### 4.1 建構子

```ts
const renderer = new Sigma(graph, container, settings);
```

* `graph`：graphology instance
* `container`：DOM element
* `settings`：可選，控制 render/互動/labels/programs 等

### 4.2 銷毀

```ts
renderer.kill();
```

* React / SPA 必做：component unmount 時 kill，避免 event listener / WebGL resource leak。

## 5. 常用設定（Settings）

> Settings 很多，以下是最常用、最有感的類別。

### 5.1 外觀

* `defaultNodeColor`, `defaultEdgeColor`
* `labelFont`, `labelSize`, `labelWeight`（實際 key 以 typedoc 為準）

### 5.2 互動

* 是否啟用 hover/點擊/拖曳（具體 key 以 typedoc / events docs 為準）
* 觸控裝置支援

### 5.3 Programs（核心與自訂渲染）

* `nodeProgramClasses` / `edgeProgramClasses`
* `hoverNodeProgramClasses`（讓 hover 用不同 program）
* `defaultNodeType` / `defaultEdgeType`

### 5.4 尺寸與座標（非常重要）

Sigma 的預設尺寸策略是「可讀性優先」，會跟 zoom 比例產生非線性關係：

* `zoomToSizeRatioFunction`：預設 `Math.sqrt`

  * 若你想讓大小跟 zoom 線性成長，可設 `(ratio) => ratio`
* `itemSizesReference`：可切換 size 的解讀座標參考
* `autoRescale`：若關掉，會停止自動把圖縮放/置中到 viewport（位置解讀會更像像素座標）

> 這三個是你做「像心智圖 / 固定排版 / 精準像素控制」時最常調的。

---

## 6. Camera（平移/縮放/置中/框選）

Sigma 的 Camera 管理視角（平移 + zoom）。常見需求：

* 初始自動置中（預設多會做）
* 點選節點後 smooth zoom-in
* fit-to-screen（把某群節點框起來）

常用概念：

* 「Graph coordinates」：你的 `x,y`
* 「Viewport/screen coordinates」：畫布像素

你通常會遇到這些操作：

* `renderer.getCamera()` 取得 camera
* camera 的 `setState` / `animate` / `updateState`（實際方法以 v3 typedoc 為準）

> 若你要「點選 node 然後置中」，本質上是把 node 的 graph coordinate 轉成 camera state。

---

## 7. Events（互動事件與 picking）

Sigma 的事件偵測大量依賴 **picking**：

* 會渲染一張「使用者看的圖」
* 另渲染一張「每個 item 用唯一顏色」的 picking 圖
* 滑鼠位置對應像素顏色 → 反查是哪個 node/edge

因此：

* 事件命中通常準確，且不需要你自己算距離
* 自訂 program 需要同時支援 normal 與 picking mode（用 `PICKING_MODE` 切換 shader 分支）

常見事件（名稱以 typedoc 為準）：

* `clickNode`, `clickEdge`
* `enterNode`, `leaveNode`（hover）
* `downNode` / `upNode`（拖曳）
* `clickStage`（點到空白處）

---

## 8. 渲染資料流程：Reducers / DisplayData / 自訂外觀

你可以把 graph 中的 attrs 轉成「顯示用資料」：

* 想做「根據屬性動態計算 size / color / label / zIndex」
* 想把外部 store 的狀態（例如 selection / highlight）映射到顯示

概念上會用到：

* node reducer / edge reducer（名稱以設定 key 為準）
* `NodeDisplayData` / `EdgeDisplayData`（renderers docs 提到 `processVisibleItem(offset, data)` 的 data）

典型做法：

1. graph 只存「原始資料」
2. reducer 根據 state 回傳「顯示資料」
3. 呼叫 `renderer.refresh()`（或等效方法）讓畫面更新

---

## 9. Renderers 與 Programs（Core WebGL 程式）

Sigma 把 WebGL 的複雜度包在 **NodeProgram / EdgeProgram**：

你要寫自訂 program 時，需要：

1. Vertex/Fragment shaders
2. Program definition（每個 item 有多少 vertices、有哪些 attributes/uniforms）
3. Program class：

   * `getDefinition()`
   * `processVisibleItem(offset: number, data: NodeDisplayData)`：把資料寫進 `this.array`
   * `draw(params: RenderParams)`：設定 uniforms + `gl.drawArrays`

### 9.1 Core programs（sigma/rendering）

**Edges：**

* `EdgeLineProgram`

  * 最快，但永遠 1px（不跟 zoom/size 變粗）
* `EdgeRectangleProgram`

  * 預設；以矩形（兩個三角形）畫「粗邊」
* `EdgeArrowProgram`

  * 組合 renderer（箭身 + 箭頭）
  * 並提供 factory：

    * `createEdgeArrowProgram`
    * `createEdgeClampedProgram`
    * `createEdgeArrowHeadProgram`

**Nodes：**

* `NodePointProgram`

  * 用 `gl.POINTS`，效能極好
  * 但半徑有上限（約 100px 等級）
* `NodeCircleProgram`

  * 以兩個三角形畫正方形，再在 fragment shader carve 成圓

---

## 10. 尺寸與座標系統（Sizes & Coordinates）

### 10.1 預設尺寸策略（非常重要）

Sigma 預設會做三件事：

1. node/edge size 會跟 zoom ratio 做 **sqrt** 縮放
2. data 中的 size 預設當作「在預設 zoom 下的像素值」
3. 會自動把圖 rescale+置中，讓整張圖塞進 viewport

### 10.2 你可以改的三個關鍵開關

* `zoomToSizeRatioFunction: (ratio) => number`

  * 預設 `Math.sqrt`
  * 想要線性：`(ratio) => ratio`
* `itemSizesReference`

  * 想讓 size 以 positions 的座標系統解讀，可用 `"positions"`
* `autoRescale: false`

  * 關掉後，positions 更像「像素座標」

> 做固定排版（例如你用 ELK 算好像素座標）通常會先試 `autoRescale: false`。

---

## 11. Layers（額外圖層）

Sigma 除了 nodes/edges 還有「額外 layer」可以畫：

* 背景（例如地圖）
* 自訂 WebGL layer（特殊效果）

官方將這類能力拆到 Satellite packages（見下）。

---

## 12. 效能與大圖最佳實務

> 你前面提過「5000+ 節點 + 中文 label + 會卡」，這裡是 sigma 常見的處方。

### 12.1 優先用 `NodePointProgram`

* 尤其在節點很多、形狀簡單時，`gl.POINTS` 通常最省。

### 12.2 Label 策略（非常關鍵）

* 不要一開始把所有 label 都畫出來
* 常見策略：

  * 只顯示「大節點」或「hover / selected」的 label
  * 縮放到某個 zoom 以上才顯示 label

### 12.3 減少 refresh 次數

* 批次更新 graph：

  * 一次加完 node/edge 再 refresh
* 互動造成樣式變更，用 reducer + refresh，但要避免每 mousemove 觸發 full refresh

### 12.4 Layout 放到 WebWorker

* layout 計算（ForceAtlas2 / Noverlap）建議 worker 版
* 算完 positions 再一次寫回 graph

### 12.5 Canvas 尺寸與 DPR

* 高 DPR（retina）會放大像素數 → WebGL 負擔變大
* 若你可接受略糊，可控制 renderer 的解析度策略（具體 key 以 typedoc 為準）

---

## 13. Satellite Packages 全整理（@sigma/*）

Sigma v3 起採 monorepo，核心是 `sigma`，其他較專門的能力拆成 `@sigma/xxx`。

官方文件提到的分類：

* `@sigma/node-xxx`：node renderer
* `@sigma/edge-xxx`：edge renderer
* `@sigma/layer-xxx`：額外 layer
* `@sigma/export-xxx`：匯出/截圖
* `@sigma/utils`：小工具

以下整理「官方 Renderers 文件列出的所有套件」+ 常見 export/utils：

### 13.1 @sigma/node-image（節點圖片）

**用途**：把 node 畫成圓形，並用圖片填滿（通常用 texture atlas 提升效能）。

**典型用法（概念）**：

1. 安裝：`npm i @sigma/node-image`
2. 建立 node program：`createNodeImageProgram(...)`
3. 設定到 `nodeProgramClasses`
4. 給 node 設 `type: "image"` 與圖片欄位（例如 `image` / `url`）

```ts
// import { createNodeImageProgram } from "@sigma/node-image";

const renderer = new Sigma(graph, container, {
  nodeProgramClasses: {
    // image: createNodeImageProgram(/* options */),
  },
});

graph.addNode("u1", {
  x: 0,
  y: 0,
  size: 12,
  label: "User",
  type: "image",
  // image: "https://...",
});
```

> Storybook 的 core rendering 範例指出有使用 `createNodeImageProgram`（名稱在 source 中出現）。

---

### 13.2 @sigma/node-border（節點邊框/同心圓）

**用途**：畫同心圓/多層圓盤，常用來做：

* 外圈邊框（selected / group color）
* 多層 ring 表示多種狀態

**典型用法（概念）**：

* 透過 factory 產生 program（例如 `createNodeBorderProgram`）
* 在 node attrs 放入邊框顏色/厚度/層數資訊（實際欄位依套件 API）

---

### 13.3 @sigma/node-piechart（節點圓餅圖）

**用途**：把節點畫成 pie chart，適合：

* 節點代表集合/分佈（例如風險類別比例）

**典型用法（概念）**：

* API 設計「受 node-border 啟發」
* node attrs 放入 pie slices（顏色 + value）

---

### 13.4 @sigma/node-square（方形節點）

**用途**：提供一個現成 program，把 node 畫成 square。

**典型用法（概念）**：

* `nodeProgramClasses: { square: NodeSquareProgram }`
* node attrs `type: "square"`

---

### 13.5 @sigma/edge-curve（曲線邊）

**用途**：把 edge 畫成 curve。

**典型用法（概念）**：

* `edgeProgramClasses: { curve: EdgeCurveProgram }`
* edge attrs `type: "curve"`
* 可選 edge attrs `curvature`（或同等欄位）控制彎曲程度

---

### 13.6 @sigma/layer-leaflet（Leaflet 地圖背景）

**用途**：把 Leaflet map 綁到 sigma 畫布後面，做地理可視化。

**典型用法（概念）**：

* 先建立 Leaflet map
* 呼叫套件提供的 `bindLeafletLayer(renderer, map, ...)`（實際函式名以 exports 為準）
* 同步 camera/zoom，讓節點座標對應地圖投影

---

### 13.7 @sigma/layer-maplibre（MapLibre 地圖背景）

**用途**：類似 leaflet 版本，但用 MapLibre（可搭 vector tiles / style）

**典型用法（概念）**：

* 建立 MapLibre map
* 綁到 sigma instance
* 同步 camera state

---

### 13.8 @sigma/layer-webgl（自訂 WebGL Layer + 基礎效果）

**用途**：

* 幫你把「額外 WebGL program」當成 layer 掛到 sigma renderer
* 並提供一些 base layers（官方文件提到：metaballs、contour lines）

**典型用法（概念）**：

* 使用套件 helper 建立 layer program
* 設定 layer 的 render order（背景/前景）

---

### 13.9 @sigma/export-image（截圖匯出 PNG/JPEG）

**用途**：把當前 sigma 畫面輸出成 image。

Storybook 中可看到選項分類（概念）：

* 要存哪些 layers（edges / nodes / labels 等）
* 輸出尺寸（width/height）
* 格式（PNG/JPEG）
* 背景色
* 檔名

**典型用法（概念）**：

* 呼叫套件提供的 `exportAsPNG(renderer, options)` 或 `capture(...)`
* 或把 canvas 轉成 blob（視套件實作）

---

### 13.10 @sigma/utils（工具集）

**用途**：放一些「很常用但不適合進 core」的小 helper。

常見可能包含：

* 顏色處理（解析/轉換）
* 幾何計算（投影、距離、bounding box）
* 事件/效能工具

---

## 14. 常見整合情境範本

### 14.1 多渲染類型（同一張圖中不同 node/edge 用不同 program）

概念：

* `nodeProgramClasses` / `edgeProgramClasses` 註冊多個 type
* 每個 node/edge attrs 指定 `type`

```ts
const renderer = new Sigma(graph, container, {
  defaultNodeType: "circle",
  defaultEdgeType: "line",
  nodeProgramClasses: {
    // circle: NodeCircleProgram,
    // image: createNodeImageProgram(...),
    // square: NodeSquareProgram,
  },
  edgeProgramClasses: {
    // line: EdgeRectangleProgram,
    // curve: EdgeCurveProgram,
  },
});

graph.addNode("a", { x: 0, y: 0, size: 8, type: "circle" });
graph.addNode("b", { x: 1, y: 0, size: 12, type: "square" });
graph.addNode("c", { x: 0, y: 1, size: 14, type: "image" /* image: ... */ });

graph.addEdge("a", "b", { type: "line" });
graph.addEdge("b", "c", { type: "curve" /* curvature: 0.4 */ });
```

---

### 14.2 固定像素排版（ELK 算好座標，不要自動縮放）

1. 把 ELK 結果寫回 node 的 `x,y`
2. 設：

* `autoRescale: false`
* 視需求調 `zoomToSizeRatioFunction`

> 這通常會讓你的座標更「所見即所得」。

---

### 14.3 大圖 label 優化（只顯示必要 label）

策略：

* reducer 根據 zoom 或 selection 決定 `label` 是否回傳
* 或用「只在 hover/selected 顯示」

概念 pseudo：

```ts
// renderer 內部通常能讀到 camera state / zoom
// reducer: (nodeKey, attrs) => ({ ...displayData })
```

---

### 14.4 匯出截圖（export-image）

建議做法：

* UI 上讓使用者選：

  * 是否包含 labels
  * 背景色
  * 尺寸（例如 1920x1080）

<a id="toc-145"></a>
### 14.5 你接下來如果要我更「完全對齊 Storybook」

如果你希望我把 **Storybook 裡 Core features / Satellite packages 的每一個 story**（包含 story 的 options/props/範例程式）逐條列出，我可以用 **直接讀取 GitHub 上 storybook 的 source 檔** 的方式做到更精準。

但目前這個回合我無法再使用網頁工具繼續開新來源；你若願意，你也可以把 `packages/storybook/stories` 的資料夾（或你關心的那幾個 `.ts/.mdx`）打包上傳，我就能逐檔把 story 的「使用方法與可調參數」完整轉寫成這份手冊的補完章節。

<a id="toc-146"></a>
### 14.6 補充：@react-sigma / Settings 參數 / 事件 Payload / 動畫（依你補充的四點整理）

> 這一段是用來把你提出的補強點「直接補進本文件」，方便日後查閱。

### A. @react-sigma（React 生態系整合）

* **定位**：React 的 wrapper／整合層，幫你把 sigma renderer 的生命週期（建立、更新、銷毀）包起來，並提供 hooks 與常見 UI 控制元件。
* **常見套件與能力**（以實務上最常用的拆法）：

  * `@react-sigma/core`：提供 `SigmaContainer` 與核心 hooks。
  * `@react-sigma/layout-forceatlas2`：提供 ForceAtlas2 layout 的 React 整合（通常含 worker 版本，避免主執行緒卡頓）。
* **SigmaContainer**：常見用途是自動處理 sigma instance 的 mount/kill，並讓子元件透過 hooks 拿到 sigma instance。
* **常用 hooks（典型）**：

  * `useSigma()`：取得 sigma instance（renderer）。
  * `useRegisterEvents()`：用 React 方式註冊/解除事件。
  * `useLoadGraph()`：把 graphology graph 載入/替換到 sigma。
* **常見 Controls 元件**：Zoom / Fullscreen / Search…等（可省去自己刻 DOM 與綁定行為）。

> 注意：@react-sigma 的各子套件與 API 可能會依版本演進；以你專案實際 lock 的版本文件為準。

### B. Settings（Configuration）中，對開發體驗很關鍵的實用參數

* `allowInvalidContainer: boolean`：允許容器寬高為 0 時初始化（常用來避免 React 初次 render 時容器尚未 layout 完成導致的初始化問題）。
* `renderEdgeLabels: boolean`：是否渲染 **邊的 label**（預設通常關閉，需要顯式開啟）。
* `zIndex: boolean`：是否啟用 zIndex 排序。若要讓特定 node/edge 永遠更上層：

  * setting 必須 `zIndex: true`
  * 資料端要提供 `zIndex` 屬性（數字越大越上層）
* `labelDensity: number` / `labelGridCellSize: number`：兩者影響「標籤顯示密度」與「label 去重疊/取樣」的網格策略，通常是你要調整「標籤太擠/太少/閃爍」時最有感的參數之一。

### C. 事件 Payload：`preventSigmaDefault` 與座標轉換（做 Tooltip 幾乎必用）

* **互動事件 Payload（click/down/enter/leave 等）**通常會帶：

  * `event`：包含發生位置座標、原始 DOM 事件等
  * `node` / `edge`：若是 node/edge 事件則會附上對應 id
* **`preventSigmaDefault()`**：用來阻止 sigma 在該事件上的預設行為（常見於：你要自己做 drag/drop、自己控制 camera 行為、或避免某些預設互動干擾你的互動流程）。
* **座標轉換（Tooltip/Overlay 必備）**：

  * `renderer.viewportToGraph(pos)`：把容器/螢幕座標轉成 graph 座標
  * `renderer.graphToViewport(pos)`：把 graph 座標轉回容器/螢幕座標

### D. 動畫 API：`camera.animate()`（概念是對的，但以實際版本型別定義為準）

* sigma 的 camera 通常支援 `animate` 來做平滑的移動/縮放/旋轉。
* 你提到的 options（如 `duration`、`easing`、`onComplete`）在概念上非常符合相機動畫 API 的常見設計；但不同版本的 sigma/camera 型別定義可能會略有差異（例如 callback 命名、easing 型別）。
* 建議做法：以 Typedoc（或你 lock 的版本 `camera.d.ts` / source）為準，把 options 的型別直接導入你的專案以獲得 TS IntelliSense。

---

## 15. 多中心群（理專 → 客戶 → 帳戶）：ELK 排版策略（純策略 + 可直接落地）

> 你已確認：資料本身就有群（例如每位理專一群），而且你要的是「真的多中心群」。
>
> 這裡不綁任何特定專案/框架：**只要最後能把 x/y 寫回 graphology，sigma 就能畫。**

### 15.1 目標

1. **群內可讀、盡量少重疊**（理專/客戶/帳戶層次清楚）
2. **群與群之間排開**（多中心，不互撞）
3. **初始載入自動挑一個群當視角中心**（由指標自動選）

### 15.2 推薦 Pipeline（最穩、最好調參）

* Step A：依資料語意拆群（每位理專一群）
* Step B：每個群內用 ELK 算 layout（預設 `layered`）
* Step C：把每個群 layout 後的 bounding box 做 packing（grid/circle）
* Step D：把結果寫回 graphology `x/y`，sigma `refresh()`
* Step E：初始載入決定 camera 對準哪個群（只影響視角，不改座標）

### 15.3 群內 layout：為什麼預設選 ELK `layered`

你的資料天然分層且有方向：

* layer0：理專
* layer1：客戶
* layer2：帳戶

`layered` 的優點是：**可讀性最高、結果最可預測、重疊最少**。

建議的 layoutOptions（你可以當 baseline）：

```ts
type ElkPrimitive = string | number | boolean;
type ElkLayoutOptions = Readonly<Record<string, ElkPrimitive>>;

export const elkLayeredAdvisorProfile: ElkLayoutOptions = {
  "elk.algorithm": "org.eclipse.elk.layered",
  "elk.direction": "RIGHT", // 或 DOWN

  // 群內節點距離（先調這兩個通常最有效）
  "elk.spacing.nodeNode": 40,
  "elk.layered.spacing.nodeNodeBetweenLayers": 60,

  // 邊線樣式：想像流程圖就 ORTHOGONAL；想柔一點就 SPLINES
  "elk.edgeRouting": "ORTHOGONAL",
};
```

> 如果某些群「客戶間互相連很多」更像網狀，你可以只對那個群換成 `elk.algorithm = org.eclipse.elk.force`；
> 但大多 B2B 場景，layered 會更清楚。

### 15.4 群間 packing：多中心不重疊的關鍵

ELK 主要幫你做「群內」。群與群之間你可以用最簡單、最穩定的方式：

* 取得每個群 layout 後的 bounding box（minX/maxX/minY/maxY）
* 用 grid packing：依 bbox 寬高把群排成多列（或多欄）
* 留一個 `componentGap`（例如 120~300）

> 這個方法不需要物理模擬，效果穩且好 debug。

### 15.5 初始載入：自動選「中心群」的指標（由我用指標選，穩定可解釋）

把「中心群」定義成：最值得先被使用者看到/置中的理專群。

對每位理專群算 score：

* `C = 客戶數`
* `A = 帳戶數`
* `E = 群內邊數`（密度輔助）
* `D = 理專節點 degree`（或理專直連客戶數）

建議預設：

`score = 3*C + 2*A + 0.2*E + 1*D`

Tie-break：score → C → A → label/id（字典序，確保結果穩定）。

### 15.6 可直接落地的 TypeScript 介面（不綁 React，不用 any）

> 下面只提供「策略實作骨架」，你可以把它接到任何資料層：

```ts
export type Role = "advisor" | "customer" | "account";

export type NodeAttrs = {
  x: number;
  y: number;
  size: number;
  role: Role;
  label?: string;

  // 如果你能給真實 UI 尺寸，ELK 重疊會更準
  width?: number;
  height?: number;
};

export type EdgeAttrs = Record<string, never>;

export type AdvisorGroupStats = {
  advisorId: string;
  customers: number;
  accounts: number;
  edges: number;
  advisorDegree: number;
  score: number;
};

export function computeAdvisorGroupScore(input: {
  customers: number;
  accounts: number;
  edges: number;
  advisorDegree: number;
}): number {
  return 3 * input.customers + 2 * input.accounts + 0.2 * input.edges + 1 * input.advisorDegree;
}

export function pickInitialFocusGroup(groups: ReadonlyArray<AdvisorGroupStats>): AdvisorGroupStats | null {
  if (groups.length === 0) return null;
  const sorted = [...groups].sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    if (b.customers !== a.customers) return b.customers - a.customers;
    if (b.accounts !== a.accounts) return b.accounts - a.accounts;
    return a.advisorId.localeCompare(b.advisorId);
  });
  return sorted[0] ?? null;
}
```

### 15.7 Sigma 端怎麼用（概念）

* 你跑完 ELK（群內）+ packing（群間）後，把每個 node 的 `x/y` 寫回 graphology
* `renderer.refresh()`
* 初始載入：找到你選出的「中心群」的 bbox，camera `fit` 或 `animate` 到該 bbox

> camera 的 API 依你實際 sigma 版本為準；策略上就是「對準那個群的 bounding box」。

### 15.8 心智圖／拓樸圖／網狀圖：常用布局演算法對照（✅你要的範例補齊）

> 你記得沒錯：這三種視覺通常對應 **不同 layout 演算法族群**。
>
> Sigma.js 不提供 layout，本節列的是「算出 x/y 的外部算法」；算完把 `x/y` 寫回 graphology，sigma 就能畫。

#### 15.8.1 拓樸圖（Topology / 分層 / 流程感）— 結構式分層（最穩、最推薦給理專→客戶→帳戶）

**典型算法族群**：Layered / Hierarchical（分層布局）

**ELK（推薦）**：`org.eclipse.elk.layered`

```ts
type ElkPrimitive = string | number | boolean;
type ElkLayoutOptions = Readonly<Record<string, ElkPrimitive>>;

export const elkTopologyLayeredProfile: ElkLayoutOptions = {
  "elk.algorithm": "org.eclipse.elk.layered",
  "elk.direction": "RIGHT", // RIGHT / LEFT / DOWN / UP

  // 先調這兩個：最影響「擁擠 vs 可讀」
  "elk.spacing.nodeNode": 40,
  "elk.layered.spacing.nodeNodeBetweenLayers": 60,

  // 流程圖感最強：ORTHOGONAL；想柔和：SPLINES；一般：POLYLINE
  "elk.edgeRouting": "ORTHOGONAL",
};
```

**適合情境**：

* 你要「層次清楚」「方向一致」「B2B 可讀性」
* 你資料天然分層（理專→客戶→帳戶）

---

#### 15.8.2 心智圖（Mind map / 放射）— 樹狀/放射（需要明確的 root/父子關係）

**典型算法族群**：Tree / Radial tree

心智圖常見兩種視覺：

1. **放射式（Radial）**：中心往外擴
2. **樹狀（Tree）**：上到下 / 左到右

**ELK（放射）**：`org.eclipse.elk.radial`

```ts
export const elkMindMapRadialProfile: ElkLayoutOptions = {
  "elk.algorithm": "org.eclipse.elk.radial",
  "elk.spacing.nodeNode": 40,
  "elk.edgeRouting": "SPLINES",
};
```

**ELK（樹狀）**：`org.eclipse.elk.mrtree`

```ts
export const elkMindMapTreeProfile: ElkLayoutOptions = {
  "elk.algorithm": "org.eclipse.elk.mrtree",
  "elk.direction": "RIGHT",
  "elk.spacing.nodeNode": 40,
  "elk.edgeRouting": "SPLINES",
};
```

**重要提醒（心智圖為什麼算法不同）**：

* 心智圖的排版本質是「樹」：你要先有 root（或抽 spanning tree / 指定 parent）
* 如果群內是高度網狀（很多交叉邊），心智圖演算法仍能排，但「父子語意」可能不符合你的領域邏輯

---

#### 15.8.3 網狀圖（Web / 關係網 / 社群）— 物理模擬（自然聚類，但較不穩、需後處理）

**典型算法族群**：Force-directed（力導向/物理模擬）

你在 sigma 生態最常見的做法是：

* **ForceAtlas2**：先把社群自然聚在一起
* **Noverlap**：再把重疊推開（強化「盡量不重疊」）

概念 pipeline：

```ts
// 1) 先跑 force（例如 ForceAtlas2）得到自然聚類座標
// 2) 再跑 noverlap 把撞在一起的節點推開
// 3) 把 x/y 寫回 graph → sigma refresh
```

**適合情境**：

* 你想看「誰跟誰很黏」「社群聚類」
* 不強求層次方向，但重疊要靠 no-overlap / spacing / iterations 調

---

#### 15.8.4 同一個畫面可以混用：每個群選不同 profile（多中心群最常見）

> 多中心群最常見的做法其實是「群內分型」：
>
> * 大多數群：layered（清楚）
> * 特別網狀的群：force（更符合關係網直覺）
> * 需要做說明/心智圖的群：radial/mrtree

建議簡單規則（策略示意）：

* 若群內 `edgeDensity` 高（交叉邊很多）→ 用網狀（force）
* 若群內接近樹（tree-likeness 高）→ 用心智圖（radial/mrtree）
* 其他預設 → 用拓樸（layered）

---
